{"componentChunkName":"component---src-templates-blog-post-js","path":"/extractive-summarizer-journey-preprocessing/","result":{"data":{"site":{"siteMetadata":{"title":"My Machine Learnings"}},"markdownRemark":{"id":"8977a115-5a7a-5db6-8222-be6b16f3fdf8","excerpt":"Get the data This example makes use the  dataset, it contains 2 features news  and their corresponding . Since you need to make sure you have enough instances…","html":"<h2>Get the data</h2>\n<p>This example makes use the <code class=\"language-text\">cnn_dailymail</code> dataset, it contains 2 features news <code class=\"language-text\">articles</code> and their corresponding <code class=\"language-text\">highlights</code>. Since you need to make sure you have enough instances to train, validate and test our model you can load the <code class=\"language-text\">train</code>, <code class=\"language-text\">validation</code> and <code class=\"language-text\">test</code> sets separately from tensorflow datasets.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ds_train = tfds.load(name=&quot;cnn_dailymail&quot;, split=&quot;train&quot;)\nds_val = tfds.load(name=&quot;cnn_dailymail&quot;, split=&quot;validation&quot;)\nds_test = tfds.load(name=&quot;cnn_dailymail&quot;, split=&quot;test&quot;)</code></pre></div>\n<p>For easier data wrangling and preprocessing, you need to transform these datasets to pandas data frames. You can either use a custom function or use the <code class=\"language-text\">as_dataframe()</code> method (nightly version). Either way, you might need to convert the returned data frame rows from bytes to string before applying further transformations.</p>\n<h2>Preliminary Cleanup</h2>\n<p>This can be the most time-consuming step. Once you obtain your dataset, you need to wrangle the data to see what it looks like and apply the necessary cleaning steps.\nThese steps can depend on the original input data. In this specific case, to extract raw text from the data, you need to remove all non-textual information by making use of regex expressions. Here is an example of text clean up for the input data using a concatenated regex expression.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># Cleanup the datasets\n# Compose concatenated regex expression to clean data faster\nstart_of_string = &quot;^\\s*&quot;\nremove_cnn = &quot;.*\\((CNN|EW.com)\\)?(\\s+--\\s+)?&quot;\nremove_by_1 = (\n    &quot;By \\.([^.*]+\\.)?([^.]*\\. PUBLISHED: \\.[^|]*\\| \\.)? UPDATED:[^.]+\\.[^.]+\\.\\s*&quot;\n)\nremove_by_2 = &quot;By \\.([^.*]+\\.)?(\\sand[^.*]+\\.\\s*)?(UPDATED[^.*]+\\.[^.*]+\\.\\s*)?(\\slast[^.*]+\\.\\s*)?&quot;\nremove_last_updated = &quot;Last[^.*]+\\.\\s&quot;\nremove_twitter_link = &quot;By \\.([^.*]+\\.)\\s*Follow\\s@@[^.*]+\\.\\s+&quot;\nremove_published = &quot;(PUBLISHED[^.*]+\\.[^.*]+\\.[^.*]+\\.\\s*)(UPDATED[^.*]+\\.[^.*]+\\.\\s*)?&quot;\n# end_of_string = &#39;[\\&#39;&quot;]*\\s*$&#39;\n\nr_cleanup_source = (\n    start_of_string\n    + &quot;(&quot;\n    + &quot;|&quot;.join(\n        [\n            remove_cnn,\n            remove_by_1,\n            remove_by_2,\n            remove_last_updated,\n            remove_twitter_link,\n            remove_published,\n        ]\n    )\n    + &quot;)&quot;\n)\n\nr_cleanup = re.compile(r_cleanup_source)</code></pre></div>\n<p>You can then apply these clean up steps on the input data using the following function.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def cleanup(text):\n    return r_cleanup.sub(&quot;&quot;, text)</code></pre></div>\n<p>After you get rid of all the irrelevant information for your analysis, you need to proceed to pre-processing the plain text you get to make it NLP software friendly.</p>\n<h2>Preprocessing</h2>\n<p>During the preprocessing steps, you need to regularly check for and deal with missing values before you pass them into nltk’s preprocessing steps because your code will not work when you pass in missing values.</p>\n<h3>Sentence Tokens</h3>\n<p>It is the process of breaking up text into sentences, the simplest way to do it would be to split at full stops, but there might be abbreviations like E.U, Ms. or Dr. that make this step less obvious.\nFortunately you can use libraries like nltk( <code class=\"language-text\">sent_tokenize</code> )or Spacy in most cases to take care of this. In the case of the <code class=\"language-text\">cnn_dailymail</code> the nltk sentence tokenizer inconsistently splits the sentences in cases like for example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">sent_tokenize(&#39;Bishop John Folda, of North Dakota, is taking time off after being diagnosed .He contracted the infection through contaminated food in Italy .Church members in Fargo, Grand Forks and Jamestown could have been exposed .&#39;)</code></pre></div>\n<p>Outputs:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[&#39;Bishop John Folda, of North Dakota, is taking time off after being diagnosed .He contracted the infection through contaminated food in Italy .Church members in Fargo, Grand Forks and Jamestown could have been exposed .&#39;]</code></pre></div>\n<p>The expected output would be:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[&#39;Bishop John Folda, of North Dakota, is taking time off after being diagnosed&#39;,&#39;He contracted the infection through contaminated food in Italy&#39;, &#39;Church members in Fargo, Grand Forks and Jamestown could have been exposed&#39;]</code></pre></div>\n<p>This might be because of the trailing whitespace between the last word of the sentence so for now, so you might want to use a custom sentence tokenizer to work around this limitation.</p>\n<p>One approach to this is to create a <code class=\"language-text\">text_id</code> out of the <code class=\"language-text\">index</code> column to be later be able to identify which sentence belongs to each text. </p>\n<p>You then split sentences the naive way by using a simple sentence boundary regex and apply it to the data.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def split_sentences(text):\n    # Segment texts into sentences\n    r_sentence_boundary = re.compile(\n        r&quot;\\s?[.!?]\\s?&quot;\n    )  # Modify this to not include abbreviations and other exceptions\n    return r_sentence_boundary.split(text)[:-1]\n\n\n# Split text by sentences\ndef split_by_sentence(df):\n    df[&quot;sentences&quot;] = df[&quot;article&quot;].apply(lambda x: split_sentences(str(x)))</code></pre></div>\n<p>Next, you make a list of tuples to keep track of <code class=\"language-text\">text_id</code> by <code class=\"language-text\">sentence</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># Make a list of (text_id, sentence_list) pairs\ndef tup_list_maker(tup_list):\n    &quot;&quot;&quot;\n    Takes a list of tuples with index 0 being the text_id and index 1 being a\n    list of sentences and broadcasts the text_id to each sentence\n    &quot;&quot;&quot;\n    final_list = []\n    for item in tup_list:\n        index = item[0]\n        sentences = item[1]\n        for sentence in sentences:\n            pair = (index, sentence)\n            final_list.append(pair)\n    return final_list</code></pre></div>\n<p>Then use this function to get each sentence with its own <code class=\"language-text\">text_id</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def create_full_tuple(df):\n    tuples = list(zip(df[&quot;text_id&quot;], [sentence for sentence in df[&quot;sentences&quot;]]))\n    tup_list = tup_list_maker(tuples)\n    # Converting the tuples list into a dataframe\n    sentences = pd.DataFrame(tup_list, columns=[&quot;text_id&quot;, &quot;sentence&quot;])\n    return sentences</code></pre></div>\n<p>And finally you assemble the full data frame with split sentences, text ids and the <code class=\"language-text\">is_summary</code> columns which is the labels columns indicating which sentence belongs to the summary.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def create_full_final_dataframe(df):\n\n    &quot;&quot;&quot;\n    Creates the final segmented dataframe with the `is_summary` column\n    &quot;&quot;&quot;\n\n    dataframe = make_text_id(df)\n    df_article, df_highlights = split_into_2_dfs(dataframe)\n\n    df_article[&quot;sentences&quot;] = df_article[&quot;article&quot;].apply(\n        lambda x: split_sentences(str(x))\n    )\n    df_highlights[&quot;sentences&quot;] = df_highlights[&quot;highlights&quot;].apply(\n        lambda x: split_sentences(str(x))\n    )\n    segmented_df_articles = create_full_tuple(df_article)\n    segmented_df_highlights = create_full_tuple(df_highlights)\n\n    # Create targets for dataframes\n    segmented_df_articles[&quot;is_summary_sentence&quot;] = 0\n    segmented_df_highlights[&quot;is_summary_sentence&quot;] = 1\n\n    # Stack the 2 dataframes and order by `text_id` column\n    return segmented_df_articles.append(\n        segmented_df_highlights, ignore_index=True\n    ).sort_values(by=[&quot;text_id&quot;])</code></pre></div>\n<h3>Word Tokens</h3>\n<p>For this step, it’s convenient to use nltk’s <code class=\"language-text\">word_tokenize</code> splitter to split each sentence into word tokens. This tokenizer splits words based on punctuation marks. Although it is not always splitting words correctly (for instance $10,000 is identified as two separate tokens [’$’, ‘10,000] and €1000 is identified as a single token [‘€1000’]),it is convenient to make use of it as a preliminary step for now.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">from nltk.tokenize import word_tokenize\ndef tokenizer(df, column):\n    df[column].dropna(inplace=True)\n    df[&quot;tokens&quot;] = df[column].apply(word_tokenize)\n    return df</code></pre></div>\n<h3>Stopwords Removal</h3>\n<p>Next you need to remove stop words, stop words are words like as, the, of, is. They carry no real meaning for the sentence so they’re not really relevant to your analysis. The nltk library provides a list of common English stop words but it is by no means standard and stop words may vary depending on the problem you’re trying to solve.\nIn this case, you could use the nltk list for simplicity.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">from nltk.corpus import stopwords\nfrom ast import literal_eval \n\ndef stop_words_remover(tokenized_sent):\n    &quot;&quot;&quot;\n    Removes stop words from a tokenized sentence\n    &quot;&quot;&quot;\n    # Convert string back to list\n\n    filtered_sentence = []\n    stop_words = set(stopwords.words(&quot;english&quot;))\n    for word in literal_eval(tokenized_sent):\n        if word not in stop_words:\n            filtered_sentence.append(word)\n    return filtered_sentence</code></pre></div>\n<h3>Stemming (Porter Stemmer)</h3>\n<p>Stemming is the process of suffix stripping, it reduces the word to a base form that is representative of all the variants of that word.</p>\n<p>A stemmer uses a set of fixed rules to decide how the word should be stripped (it might not always end up in a linguistically correct base form).\nFor this analysis, you can use nltk’s Porter Stemmer for its simplicity and speed.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">from nltk.stem import PorterStemmer\nfrom ast import literal_eval\nimport pandas as pd\n\nporter = PorterStemmer()\n\ndef stemmer(stemmed_sent):\n    &quot;&quot;&quot;\n    Removes stop words from a tokenized sentence\n    &quot;&quot;&quot;\n    porter = PorterStemmer()\n    stemmed_sentence = []\n    for word in literal_eval(stemmed_sent):\n        stemmed_word = porter.stem(word)\n        stemmed_sentence.append(stemmed_word)\n    return stemmed_sentence</code></pre></div>\n<p>Voilà ! You just cleaned and preprocessed text data for text summarisation. The next step is feature engineering to extract important characteristics of the text to then feed it to our machine learning algorithm.</p>","frontmatter":{"title":"Extractive Summarizer Journey: Preprocessing","date":"September 07, 2020","description":"How to preprocess text data for NLP."}}},"pageContext":{"slug":"/extractive-summarizer-journey-preprocessing/","previous":null,"next":null}},"staticQueryHashes":["3589320610","429182116"]}